# UX Polish Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix 8 usability issues: toolbar/loop-row overflow, bar-snap right-trim, beat grid on waveform, global keyboard shortcuts, multi-delete, multi-drag, and low-bitrate flag.

**Architecture:** All changes are in `ui/main_window.py` and `ui/waveform_dj.py`. No new files. Each task is independently commit-able. Tests go in `tests/test_analyzer_speed.py`.

**Tech Stack:** PyQt6, numpy, `QShortcut`/`QKeySequence` (replaces `keyPressEvent`), `QColor`, numpy vectorised beat-grid computation.

---

### Task 1: Fix toolbar — pin `?` to right edge

**Files:**
- Modify: `ui/main_window.py` — `_build_toolbar()` (~line 362)

**Step 1: Move `addStretch()` before search box**

In `_build_toolbar()`, replace:
```python
        self.search_box = QLineEdit()
        self.search_box.setPlaceholderText("Search tracks…")
        self.search_box.setFixedHeight(32)
        self.search_box.setMaximumWidth(280)
        lay.addWidget(self.search_box)

        btn_help = QPushButton("?")
        btn_help.setObjectName("btn_help")
        btn_help.setFixedSize(32, 32)
        btn_help.setToolTip("Help / keyboard shortcuts  (F1)")
        btn_help.clicked.connect(self._show_help)
        lay.addWidget(btn_help)

        lay.addStretch()
```
with:
```python
        lay.addStretch()   # ← push search + ? to right edge

        self.search_box = QLineEdit()
        self.search_box.setPlaceholderText("Search tracks…")
        self.search_box.setFixedHeight(32)
        self.search_box.setMaximumWidth(280)
        lay.addWidget(self.search_box)

        btn_help = QPushButton("?")
        btn_help.setObjectName("btn_help")
        btn_help.setFixedSize(32, 32)
        btn_help.setToolTip("Help / keyboard shortcuts  (F1)")
        btn_help.clicked.connect(self._show_help)
        lay.addWidget(btn_help)
        # no trailing addStretch()
```

**Step 2: Smoke-test**

Run: `conda run -n dj-analyzer python -c "from PyQt6.QtWidgets import QApplication; import sys; app = QApplication(sys.argv); from ui.main_window import MainWindow; print('OK')"`
Expected: `OK`

**Step 3: Commit**

```bash
git add ui/main_window.py
git commit -m "fix: pin search+? to right edge of toolbar"
```

---

### Task 2: Remove `⟳ LOOP` toggle button

**Files:**
- Modify: `ui/main_window.py` — `_build_loop_row()` (~line 678), `_snap_loop()` (~line 888), `_refresh_loop_buttons()` (~line 914)

**Step 1: Remove from `_build_loop_row()`**

Delete the three lines that create `btn_loop_toggle`:
```python
        self.btn_loop_toggle = QPushButton("⟳ LOOP")
        self.btn_loop_toggle.setFixedSize(76, 26)
        self.btn_loop_toggle.setToolTip("Toggle loop on/off  (key: L)")
        self.btn_loop_toggle.setEnabled(False)
        self.btn_loop_toggle.clicked.connect(self._toggle_loop)
        lay.addWidget(self.btn_loop_toggle)
```

**Step 2: Remove `btn_loop_toggle` reference from `_snap_loop()`**

In `_snap_loop()`, remove the line:
```python
        self.btn_loop_toggle.setEnabled(True)
```

**Step 3: Remove `btn_loop_toggle` lines from `_refresh_loop_buttons()`**

Delete these two lines from `_refresh_loop_buttons()`:
```python
        both_set = self._loop_a is not None and self._loop_b is not None
        self.btn_loop_toggle.setEnabled(both_set)
        self.btn_loop_toggle.setStyleSheet(green_style if self._loop_active else "")
```

**Step 4: Smoke-test**

Run: `conda run -n dj-analyzer python -c "from PyQt6.QtWidgets import QApplication; import sys; app = QApplication(sys.argv); from ui.main_window import MainWindow; print('OK')"`
Expected: `OK`

**Step 5: Full tests**

Run: `conda run -n dj-analyzer python -m pytest tests/ -v`
Expected: 13 passed

**Step 6: Commit**

```bash
git add ui/main_window.py
git commit -m "feat: remove redundant LOOP toggle button — OUT handles loop start/stop"
```

---

### Task 3: Bar-snap trims OUT (right edge), keeps IN fixed

**Files:**
- Modify: `ui/main_window.py` — `_snap_loop()` (~line 888)
- Test: `tests/test_analyzer_speed.py`

**Step 1: Write failing test**

Add to `tests/test_analyzer_speed.py`:
```python
def test_bar_snap_right_trim_keeps_in_fixed():
    """When IN is set, bar-snap keeps IN fixed and only adjusts OUT."""
    bpm = 128.0
    duration = 240.0
    secs_per_bar = 4.0 * 60.0 / bpm   # 1.875 s

    # IN already set at 0.25 (60 s)
    loop_a = 0.25
    a_secs = loop_a * duration          # 60.0 s

    # Press "4" bar snap
    bars = 4
    b_secs = min(a_secs + bars * secs_per_bar, duration)
    loop_b = b_secs / duration

    assert loop_b > loop_a
    expected_len = bars * secs_per_bar / duration
    assert abs((loop_b - loop_a) - expected_len) < 0.001
```

**Step 2: Run test to confirm it passes (pure math check)**

Run: `conda run -n dj-analyzer python -m pytest tests/test_analyzer_speed.py::test_bar_snap_right_trim_keeps_in_fixed -v`
Expected: PASS (this verifies the math, not the widget)

**Step 3: Update `_snap_loop()` implementation**

Replace the entire method body with:
```python
    def _snap_loop(self, bars: float) -> None:
        if not self.current_track:
            return
        bpm = self.current_track.get('bpm')
        if not bpm:
            self._status.showMessage("Analyze track first to get BPM for bar snap.")
            return
        total = self.current_track.get('duration', 0)
        if total <= 0:
            return
        secs_per_bar = 4.0 * 60.0 / float(bpm)

        if self._loop_a is not None:
            # IN already set: keep it fixed, only adjust OUT (right edge)
            a_secs = self._loop_a * total
        else:
            # No IN yet: snap from current playhead position
            cur_secs = self.audio_player.get_position() * total
            bar_num = round(cur_secs / secs_per_bar)
            a_secs = bar_num * secs_per_bar
            self._loop_a = a_secs / total

        b_secs = min(a_secs + bars * secs_per_bar, total)
        self._loop_b = b_secs / total
        self._loop_active = True
        self._refresh_loop_buttons()
        self._refresh_waveform_overlays()
        label = "½" if bars == 0.5 else str(int(bars))
        self._status.showMessage(
            f"Loop: {label} bar(s) · {a_secs:.2f}s → {b_secs:.2f}s"
        )
```

**Step 4: Run full tests**

Run: `conda run -n dj-analyzer python -m pytest tests/ -v`
Expected: 14 passed

**Step 5: Commit**

```bash
git add ui/main_window.py tests/test_analyzer_speed.py
git commit -m "feat: bar-snap trims OUT from IN point when IN is already set"
```

---

### Task 4: Beat/bar grid on waveform

**Files:**
- Modify: `ui/waveform_dj.py` — `_BaseWaveform.__init__`, `paintEvent`, new `_draw_beat_grid`, new `set_beat_grid`; `WaveformDJ` — new `set_beat_grid`
- Modify: `ui/main_window.py` — `_display_track()` (~line 1168)
- Test: `tests/test_analyzer_speed.py`

**Step 1: Write failing test**

Add to `tests/test_analyzer_speed.py`:
```python
def test_beat_grid_line_count():
    """Beat grid should generate correct number of beat positions for given BPM/duration."""
    bpm = 120.0
    duration = 60.0   # 1 minute = 120 beats
    secs_per_beat = 60.0 / bpm   # 0.5 s
    expected_beats = int(duration / secs_per_beat)  # 120

    beats = []
    t = 0.0
    while t < duration:
        beats.append(t)
        t += secs_per_beat

    assert len(beats) == expected_beats
    assert beats[0] == 0.0
    assert abs(beats[-1] - (duration - secs_per_beat)) < 0.001
```

**Step 2: Run to verify it passes (pure math)**

Run: `conda run -n dj-analyzer python -m pytest tests/test_analyzer_speed.py::test_beat_grid_line_count -v`
Expected: PASS

**Step 3: Add `set_beat_grid` and `_draw_beat_grid` to `_BaseWaveform`**

In `_BaseWaveform.__init__()`, add:
```python
        self._beat_grid: tuple | None = None   # (bpm: float, duration: float)
```

Add method after `set_loop()`:
```python
    def set_beat_grid(self, bpm: float | None, duration: float) -> None:
        """Set BPM + duration so beat/bar lines can be painted on the waveform."""
        if bpm and bpm > 0 and duration > 0:
            self._beat_grid = (float(bpm), float(duration))
        else:
            self._beat_grid = None
        self.update()
```

Add method after `set_beat_grid`:
```python
    def _draw_beat_grid(self, painter: QPainter, w: int, h: int) -> None:
        """Draw semi-transparent beat (thin) and bar (full-height) tick marks."""
        if self._beat_grid is None:
            return
        bpm, duration = self._beat_grid
        secs_per_beat = 60.0 / bpm
        beat = 0
        t = 0.0
        while t < duration:
            x = int((t / duration) * w)
            is_bar = (beat % 4 == 0)
            alpha  = 55 if is_bar else 20
            ht     = h  if is_bar else h // 2
            y_top  = (h - ht) // 2
            painter.setPen(QPen(QColor(255, 255, 255, alpha), 1))
            painter.drawLine(x, y_top, x, y_top + ht)
            beat += 1
            t    += secs_per_beat
```

In `paintEvent`, insert `_draw_beat_grid` call **between** `_draw_waveform` and `_draw_loop_region`:
```python
        self._draw_waveform(painter, w, h)
        self._draw_beat_grid(painter, w, h)    # ← new line
        self._draw_loop_region(painter, w, h)
        self._draw_cue_markers(painter, w, h)
        self._draw_playhead(painter, w, h)
```

**Step 4: Add `set_beat_grid` to `WaveformDJ`**

In `WaveformDJ`, add after `update_cues_and_loop()`:
```python
    def set_beat_grid(self, bpm: float | None, duration: float) -> None:
        """Forward BPM/duration to the base waveform for beat-grid painting."""
        self.main.set_beat_grid(bpm, duration)
```

**Step 5: Call `set_beat_grid` from `_display_track()`**

In `ui/main_window.py`, in `_display_track()`, after the line `self.waveform.set_waveform_from_file(...)`:
```python
            self.waveform.set_beat_grid(float(bpm) if bpm else None, float(dur_sec))
```

Also clear the grid in `_on_clear_track()` or wherever `self.waveform.clear()` is called — find all `self.waveform.clear()` calls and add `self.waveform.set_beat_grid(None, 0)` after each.

**Step 6: Run full tests**

Run: `conda run -n dj-analyzer python -m pytest tests/ -v`
Expected: 15 passed

**Step 7: Commit**

```bash
git add ui/waveform_dj.py ui/main_window.py tests/test_analyzer_speed.py
git commit -m "feat: beat/bar grid on waveform — subtle tick marks at each beat and bar"
```

---

### Task 5: Global keyboard shortcuts via `QShortcut`

**Files:**
- Modify: `ui/main_window.py` — imports (~line 1), `__init__` (~line 308), add `_setup_shortcuts()`, remove `keyPressEvent`

**Step 1: Add `QShortcut` import**

At the top of `ui/main_window.py`, in the `from PyQt6.QtGui import ...` block, add `QShortcut, QKeySequence`:
```python
from PyQt6.QtGui import (
    QColor, QKeyEvent, QIcon, QShortcut, QKeySequence,
    # ... whatever else is there
)
```

**Step 2: Add `_setup_shortcuts()` method**

Add this method just above `keyPressEvent` (or near the other setup methods):
```python
    def _setup_shortcuts(self) -> None:
        """Register window-wide shortcuts that fire regardless of which child widget is focused."""
        def _space():
            if not isinstance(QApplication.focusWidget(), QLineEdit):
                self._toggle_playback()

        def _enter():
            if self.track_table.hasFocus() or self.track_table.viewport().hasFocus():
                self._play_selected_track(self.track_table)
            elif self.playlist_table.hasFocus() or self.playlist_table.viewport().hasFocus():
                self._play_selected_track(self.playlist_table)

        def _delete():
            fw = QApplication.focusWidget()
            if not isinstance(fw, QLineEdit):
                if self.playlist_table.hasFocus() or self.playlist_table.viewport().hasFocus():
                    self._delete_selected_playlist_tracks()

        pairs = [
            (QKeySequence(Qt.Key.Key_Space),        _space),
            (QKeySequence(Qt.Key.Key_Left),         lambda: self._skip(-5)),
            (QKeySequence("Shift+Left"),            lambda: self._skip(-30)),
            (QKeySequence(Qt.Key.Key_Right),        lambda: self._skip(5)),
            (QKeySequence("Shift+Right"),           lambda: self._skip(30)),
            (QKeySequence(Qt.Key.Key_I),            self._set_loop_a),
            (QKeySequence(Qt.Key.Key_O),            self._set_loop_b),
            (QKeySequence(Qt.Key.Key_L),            self._toggle_loop),
            (QKeySequence(Qt.Key.Key_F1),           self._show_help),
            (QKeySequence(Qt.Key.Key_Return),       _enter),
            (QKeySequence(Qt.Key.Key_Enter),        _enter),
            (QKeySequence(Qt.Key.Key_Delete),       _delete),
        ]
        for seq, slot in pairs:
            sc = QShortcut(seq, self)
            sc.activated.connect(slot)

        # Cue shortcuts: 1–6 (set) and Shift+1–6 (clear)
        for n in range(1, 7):
            idx = n - 1
            sc_plain = QShortcut(QKeySequence(getattr(Qt.Key, f"Key_{n}")), self)
            sc_plain.activated.connect(lambda i=idx: self._on_cue_clicked(i))
            sc_shift = QShortcut(QKeySequence(f"Shift+{n}"), self)
            sc_shift.activated.connect(lambda i=idx: self._clear_cue(i))
```

**Step 3: Call `_setup_shortcuts()` from `__init__`**

In `MainWindow.__init__()`, after `self._init_ui()`, add:
```python
        self._setup_shortcuts()
```

**Step 4: Remove `keyPressEvent`**

Delete the entire `keyPressEvent` method (it is now replaced by `_setup_shortcuts`). The method spans approximately lines 1350–1391.

**Step 5: Run smoke-test + full tests**

Run: `conda run -n dj-analyzer python -c "from PyQt6.QtWidgets import QApplication; import sys; app = QApplication(sys.argv); from ui.main_window import MainWindow; print('OK')"` && `conda run -n dj-analyzer python -m pytest tests/ -v`
Expected: OK / 15 passed

**Step 6: Commit**

```bash
git add ui/main_window.py
git commit -m "fix: replace keyPressEvent with QShortcut so shortcuts work when tables have focus"
```

---

### Task 6: Multi-delete from playlist

**Files:**
- Modify: `ui/main_window.py` — `_delete_selected_playlist_track()` (~line 1330)
- Test: `tests/test_analyzer_speed.py`

**Step 1: Write failing test**

Add to `tests/test_analyzer_speed.py`:
```python
def test_multi_delete_collects_unique_rows():
    """Multi-delete should collect all selected row indices, deduplicated."""
    # Simulate: selectedItems() returns items from rows 0, 1, 2
    # (each row has 3 columns so 9 items total, rows repeated)
    class FakeItem:
        def __init__(self, row): self._row = row
        def row(self): return self._row

    items = [FakeItem(r) for r in [0, 0, 0, 1, 1, 1, 2, 2, 2]]
    unique_rows = sorted({item.row() for item in items}, reverse=True)
    assert unique_rows == [2, 1, 0]
```

**Step 2: Run to confirm it passes (pure logic)**

Run: `conda run -n dj-analyzer python -m pytest tests/test_analyzer_speed.py::test_multi_delete_collects_unique_rows -v`
Expected: PASS

**Step 3: Rename and rewrite the method**

Replace `_delete_selected_playlist_track` entirely with `_delete_selected_playlist_tracks`:
```python
    def _delete_selected_playlist_tracks(self) -> None:
        """Remove all selected rows from the current playlist in one pass."""
        selected_rows = sorted(
            {item.row() for item in self.playlist_table.selectedItems()},
            reverse=True,
        )
        if not selected_rows:
            return
        # Collect file paths before modifying the table
        paths_to_remove = []
        for row in selected_rows:
            fp_item = self.playlist_table.item(row, 0)
            if fp_item:
                fp = fp_item.data(Qt.ItemDataRole.UserRole)
                if fp:
                    paths_to_remove.append(fp)
        # Batch-remove from the playlist data model, then refresh once
        idx = self.playlist_selector.currentIndex()
        if idx < 0 or not paths_to_remove:
            return
        pl = self._playlists[idx]
        for fp in paths_to_remove:
            if fp in pl['tracks']:
                pl['tracks'].remove(fp)
        self._save_playlists()
        self._refresh_playlist_table()
```

**Step 4: Update `_setup_shortcuts` Delete handler to use the new name**

The Delete handler written in Task 5 already calls `self._delete_selected_playlist_tracks()` — verify this is correct.

Also update the old `keyPressEvent` reference if it exists anywhere else (grep for `_delete_selected_playlist_track` without the final `s`).

Run: `grep -n "_delete_selected_playlist_track" ui/main_window.py` — should only show the new `_tracks` form.

**Step 5: Run full tests**

Run: `conda run -n dj-analyzer python -m pytest tests/ -v`
Expected: 16 passed

**Step 6: Commit**

```bash
git add ui/main_window.py tests/test_analyzer_speed.py
git commit -m "feat: multi-delete selected playlist tracks with a single Delete press"
```

---

### Task 7: Multi-drag from library to playlist

**Files:**
- Modify: `ui/main_window.py` — `DraggableLibraryTable.mimeData()` (~line 72), `PlaylistDropTable.dropEvent()` (~line 106), library table selection mode (~line 421)

**Step 1: Change library selection mode to ExtendedSelection**

In `__init__` where `self.track_table` is configured (~line 421):
```python
        self.track_table.setSelectionMode(QTableWidget.SelectionMode.ExtendedSelection)
```
(was `SingleSelection`)

**Step 2: Update `DraggableLibraryTable.mimeData()` to encode all selected rows**

Replace the entire `mimeData` method:
```python
    def mimeData(self, items):
        data = super().mimeData(items)
        if items:
            rows = sorted({item.row() for item in items})
            paths = []
            for row in rows:
                fp_item = self.item(row, 0)
                if fp_item:
                    fp = fp_item.data(Qt.ItemDataRole.UserRole)
                    if fp:
                        paths.append(str(fp))
            if paths:
                data.setText("\n".join(paths))
        return data
```

**Step 3: Update `PlaylistDropTable.dropEvent()` to handle newline-separated paths**

Replace the entire `dropEvent` method:
```python
    def dropEvent(self, event):
        if event.mimeData().hasText():
            for fp in event.mimeData().text().split("\n"):
                fp = fp.strip()
                if fp:
                    self.file_dropped.emit(fp)
            event.acceptProposedAction()
        else:
            super().dropEvent(event)
```

**Step 4: Run full tests**

Run: `conda run -n dj-analyzer python -m pytest tests/ -v`
Expected: 16 passed

**Step 5: Commit**

```bash
git add ui/main_window.py
git commit -m "feat: multi-select and drag multiple tracks from library to playlist"
```

---

### Task 8: Low-bitrate flag (< 320 kbps) in library

**Files:**
- Modify: `ui/main_window.py` — `_update_row_from_results()` (~line 1081)
- Test: `tests/test_analyzer_speed.py`

**Step 1: Write failing test**

Add to `tests/test_analyzer_speed.py`:
```python
def test_low_bitrate_flag_threshold():
    """Tracks below 320 kbps should be flagged; 320+ should not."""
    def should_flag(bitrate):
        return bitrate is not None and bitrate > 0 and bitrate < 320

    assert should_flag(128)  is True
    assert should_flag(256)  is True
    assert should_flag(319)  is True
    assert should_flag(320)  is False
    assert should_flag(0)    is False
    assert should_flag(None) is False
```

**Step 2: Run to confirm it passes (pure logic)**

Run: `conda run -n dj-analyzer python -m pytest tests/test_analyzer_speed.py::test_low_bitrate_flag_threshold -v`
Expected: PASS

**Step 3: Apply flag in `_update_row_from_results()`**

At the end of `_update_row_from_results()`, after the `✓` status item is set (~line 1107), add:
```python
        # Low-bitrate flag: mark tracks below 320 kbps in orange
        ai = results.get('audio_info', {})
        br = ai.get('bitrate', 0)
        name_item = self.track_table.item(row, 0)
        if name_item and br and 0 < br < 320:
            stem = Path(file_path).stem
            name_item.setText(f"⚑ {stem}")
            name_item.setForeground(QColor("#FF8C00"))
            name_item.setToolTip(f"Low bitrate: {br} kbps (< 320 kbps)\n{file_path}")
```

Note: `Path` is already imported at the top of the file.

**Step 4: Run full tests**

Run: `conda run -n dj-analyzer python -m pytest tests/ -v`
Expected: 17 passed

**Step 5: Commit**

```bash
git add ui/main_window.py tests/test_analyzer_speed.py
git commit -m "feat: orange ⚑ flag on library tracks below 320 kbps"
```

---

## Post-completion

After all 8 tasks pass:

Run final verification:
```bash
conda run -n dj-analyzer python -m pytest tests/ -v
conda run -n dj-analyzer python -c "from PyQt6.QtWidgets import QApplication; import sys; app = QApplication(sys.argv); from ui.main_window import MainWindow; print('OK')"
git log --oneline -10
```

Then invoke `superpowers:finishing-a-development-branch`.
